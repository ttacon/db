package main

import (
	"bytes"
	"database/sql"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"text/template"

	_ "github.com/go-sql-driver/mysql"
	"github.com/ttacon/chalk"
	"github.com/ttacon/pouch/pouch/defs"
	"golang.org/x/tools/imports"
)

var (
	// where to put the generated code
	targetPkg = flag.String("pkg", "", "package to inspect to")
	pkgName   = flag.String("pName", "", "pkg name for the generated files")

	// TODO(ttacon): dsn or individual parts?
	// for DB mode
	host     = flag.String("h", "", "db host to connect to")
	user     = flag.String("u", "", "user to connect to db as")
	password = flag.String("p", "", "password to authenticate user with")
	database = flag.String("db", "", "database to read tables from")
	fullDsn  = flag.String("dsn", "", "the uri to use to connect to the database")

	// modes
	// TODO(ttacon): more detailed, yet still succinct, usage message
	dbDiff       = flag.Bool("db-diff", false, "identify differences between db/code")
	codeMode     = flag.Bool("ff", false, "only use files as source")
	onlyCodeMode = flag.Bool("ff-dry-run", false, "dry run of created tables from structs")
	beastMode    = flag.Bool("beast-mode", false, "force create tables and code")

	// Prompts
	prompt     = chalk.Green.NewStyle().Style
	warning    = chalk.Yellow.NewStyle().Style
	errorP     = chalk.Red.NewStyle().Style
	dbgenPrmpt = chalk.Magenta.Color("[pouch]")

	// Other things we need...
	gopath = os.Getenv("GOPATH")
)

var (
	errorX  = errorP("✗")
	checkY2 = prompt("✔")
	checkY  = chalk.Green.Color("✔")
	// checkY2 does not give same output as checkY
)

func main() {
	flag.Parse()

	// a little varialble overriding
	*codeMode = *codeMode || *onlyCodeMode

	err := loadTemplates()
	if err != nil {
		fmt.Println(dbgenPrmpt, "failed to load templates: "+err.Error())
		return
	}

	if len(*targetPkg) == 0 {
		cwd, err := os.Getwd()
		if err != nil {
			fmt.Println(
				dbgenPrmpt,
				errorP("no target pkg provided + "+
					"failed to retrieve current directory"))
			return
		}
		*targetPkg = cwd
	} else {
		*targetPkg = filepath.Join(gopath, "src", *targetPkg)
	}

	var dirPkg = filepath.Base(*targetPkg)
	if len(*pkgName) > 0 {
		dirPkg = *pkgName
	}

	if *dbDiff {
		dbConn, err := getDBConn(*host, *user, *password, *database)
		if err != nil {
			fmt.Println(dbgenPrmpt, "failed to connect to database: "+err.Error())
			return
		}
		dbEntities, err := generateStructsFrom(dbConn)
		if err != nil {
			fmt.Println(dbgenPrmpt, "failed to generate structs from db: "+err.Error())
			os.Exit(1)
		}

		fileEntities, err := StructsFromFile(*targetPkg)
		if err != nil {
			fmt.Println(dbgenPrmpt, "failed to retrieve structs: "+err.Error())
			os.Exit(1)
		}

		diffAndReport(dbEntities, fileEntities)
		return
	}

	var (
		structFileNeeded = false
		createTables     = true
		entities         []*defs.StructInfo
	)

	if dbInfoProvided(*host, *user, *password, *database) && !*codeMode {
		// TODO(ttacon): add option for specific table(s) to be generated for
		dbConn, err := getDBConn(*host, *user, *password, *database)
		if err != nil {
			fmt.Println(dbgenPrmpt, "failed to connect to database: "+err.Error())
			return
		}
		entities, err = generateStructsFrom(dbConn)
		if err != nil {
			fmt.Println(dbgenPrmpt, "failed to generate structs: "+err.Error())
			os.Exit(1)
		}
		dbConn.Close()
		structFileNeeded = true
	} else {
		// we're reading from the file system
		entities, err = StructsFromFile(*targetPkg)
		if err != nil {
			fmt.Println(dbgenPrmpt, "failed to retrieve structs: "+err.Error())
			os.Exit(1)
		}
		createTables = true
	}

	// check structs for field conflicts
	err = nameConflicts(entities)
	if err != nil {
		fmt.Println(dbgenPrmpt, errorP("name conflicts: "+err.Error()))
		os.Exit(1)
	}

	// file generation
	if structFileNeeded {
		fBytes, err := generateStructCode(entities)
		if err != nil {
			fmt.Println(dbgenPrmpt, "failed to generate struct file, err:", err)
			return
		}

		fBuf := bytes.NewBufferString("package " + dirPkg + "\n\n")
		fBuf.WriteString(`
// THIS FILE IS GENERATED BY pouch.
// EDIT AT YOUR OWN PERIL.
`)
		fBuf.Write(fBytes)
		fBuf.WriteString("\n\n")

		process, err := imports.Process("", fBuf.Bytes(), nil)
		if err != nil {
			fmt.Println(dbgenPrmpt, "failed to process imports for struct file:", err)
			return
		}

		fmt.Print(dbgenPrmpt, " writing file structs.pch.go: ")
		err = ioutil.WriteFile(
			filepath.Join(*targetPkg, "structs.pch.go"),
			process,
			os.FileMode(0744))
		if err != nil {
			fmt.Println(errorX)
			fmt.Println("err: ", err)
			return
		}
		fmt.Println(checkY)
	}

	// prompt user to create tables on db
	if createTables {
		if len(entities) == 0 {
			fmt.Println(dbgenPrmpt, "no entities to create tables for")
			return
		}

		dbConn, err := getDBConn(*host, *user, *password, *database)
		if err != nil {
			fmt.Println(dbgenPrmpt, "failed to connect to database: "+err.Error())
			return
		}

		dbEntities, err := generateStructsFrom(dbConn)
		if err != nil {
			fmt.Println(dbgenPrmpt, "failed to generate structs: "+err.Error())
			os.Exit(1)
		}

		woTable := diffContained(dbEntities, entities)
		if len(woTable) == 0 {
			fmt.Println(dbgenPrmpt, "all annotated structs have associated tables")
			if *onlyCodeMode {
				return
			}
		} else {
			if *onlyCodeMode {
				fmt.Println(dbgenPrmpt, "there are structs unknown to the db:")
				for i, wo := range woTable {
					fmt.Printf("\t[%d] %s\n", i+1, wo.Name)
				}
				fmt.Println(dbgenPrmpt, "(to force create, run in -beast-mode)")
				return
			}

			// TODO(ttacon): create tables from structs
			err = createTablesFn(dbConn, woTable)
			if err != nil {
				fmt.Println(dbgenPrmpt, errorP("failed to create tables"))
				os.Exit(1)
			}
		}
	}

	fmt.Print(dbgenPrmpt, " generating functions (functions.pch.go): ")
	funcCode, err := generateFunctions(entities)
	if err != nil {
		fmt.Println(errorX)
		fmt.Println("err: ", err)
		return
	}

	fBuf := bytes.NewBufferString("package " + dirPkg + "\n\n")
	fBuf.WriteString(`
// THIS FILE IS GENERATED BY pouch.
// EDIT AT YOUR OWN PERIL.
`)
	fBuf.Write(funcCode)
	fBuf.WriteString("\n\n")

	funcCode, err = imports.Process("", fBuf.Bytes(), nil)
	if err != nil {
		fmt.Println(errorX)
		fmt.Println("err: ", err)
		return
	}

	err = ioutil.WriteFile(
		filepath.Join(*targetPkg, "functions.pch.go"),
		funcCode,
		os.FileMode(0644))
	if err != nil {
		fmt.Println(errorX)
		fmt.Println("err: ", err)
		return
	}

	fmt.Println(checkY)
}

func dbInfoProvided(ss ...string) bool {
	for _, s := range ss {
		if len(s) > 0 {
			return true
		}
	}
	return false
}

func getDBConn(host, username, password, database string) (*sql.DB, error) {
	return sql.Open("mysql",
		fmt.Sprintf("%s:%s@%s/%s?parseTime=true", username, password, host, database))
}

// templates
var (
	structTmplt                                  *template.Template
	identifiableT                                *template.Template
	insertableT, tableablT, findableT, gettableT *template.Template
)

func loadTemplates() error {
	var err error
	structTmplt, err = template.New("struct").Parse(structTemplate)
	if err != nil {
		return err
	}

	identifiableT, err = template.New("identifiable").Parse(identifiableTemplate)
	if err != nil {
		return err
	}

	insertableT, err = template.New("insertable").Parse(insertableTemplate)
	if err != nil {
		return err
	}

	tableablT, err = template.New("tableable").Parse(tableableTemplate)
	if err != nil {
		return err
	}

	findableT, err = template.New("findable").Parse(findableTemplate)
	if err != nil {
		return err
	}

	gettableT, err = template.New("gettable").Parse(gettableTemplate)
	if err != nil {
		return err
	}

	return nil
}

func nameConflicts(es []*defs.StructInfo) error {
	for _, e := range es {
		for _, field := range e.Fields {
			if _, ok := functionNames[field.Name]; ok {
				return errors.New(e.Name + "." + field.Name)
			}
		}
	}
	return nil
}

var functionNames = map[string]struct{}{
	"Table":              struct{}{},
	"FindableCopy":       struct{}{},
	"FieldsFor":          struct{}{},
	"InsertableFields":   struct{}{},
	"SetIdentifier":      struct{}{},
	"IdentifiableFields": struct{}{},
	"GetFieldsFor":       struct{}{},
	"GetAllFields":       struct{}{},
}

////////// templates for function generation //////////
////////// these will go in own file after we test them //////////
var structTemplate = `
type {{.Name}} struct { {{range $i, $v := .Fields}}
    {{$v.Name}} {{if $v.IsPointer}}*{{end}}{{$v.Type}}{{end}}
}
`

// Identifiable
var identifiableTemplate = `
func (i *{{.Name}}) IdentifiableFields() ([]string, []interface{}) {
    var (
        cols []string
        fields []interface{}
    ){{range $i, $v := .Fields}}{{if $v.IsPrimaryKey}}
    // adding primary key column/field pair {{$v.Name}}
    cols = append(cols, "{{$v.Column}}")
    fields = append(fields, i.{{$v.Name}}){{end}}{{end}}
    return cols, fields
}
`

// TODO(ttacon): do we need insertable fields??
// as in, do we need to differentiate "empty" or not?
// it seems like added complexity that isn't entirely necessary
// Insertable
var insertableTemplate = `
func (i *{{.Name}}) FieldsFor(fs []string) []interface{} {
    var fields = make([]interface{}, len(fs))

    for ii, f := range fs {
        switch f { {{range $i, $v := .Fields}}
        case "{{$v.Column}}":
            fields[ii] = &i.{{$v.Name}}{{end}}
        }
    }
    return fields
}

func (i *{{.Name}}) InsertableFields() ([]string, []interface{}) {
    return nil, nil
}

func (i *{{.Name}}) SetIdentifier(d interface{}) error { {{if not .HasAutoGenIDField}}
    return nil
    {{else}}
    id, _ := d.(int64)
    i.{{.IDField}} = int(id)
    return nil
{{end}}}
`

// Tableable
var tableableTemplate = `
func (t *{{.Name}}) Table() string {
    return "{{.Table}}"
}
`

// Findable:FindableCopy
var findableTemplate = `
func (f *{{.Name}}) FindableCopy() pouch.Findable {
    return &{{.Name}}{}
}
`

// Gettable
var gettableTemplate = `
func (g *{{.Name}}) GetFieldsFor(fs []string) []interface{} {
    var fields = make([]interface{}, len(fs))

    for i, f := range fs {
        switch f { {{range $i, $v := .Fields}}
        case "{{$v.Column}}":
            fields[i] = &g.{{$v.Name}}{{end}}
        }
    }
    return fields
}

func (g *{{.Name}}) GetAllFields() ([]string, []interface{}) {
    var cols  = []string{ {{range $i, $v := .Fields}}
        "{{$v.Column}}",{{end}}
    }
    var fields = []interface{}{ {{range $i, $v := .Fields}}
        &g.{{$v.Name}},{{end}}
    }
    return cols, fields
}
`
