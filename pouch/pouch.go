package main

import (
	"bytes"
	"database/sql"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	_ "github.com/go-sql-driver/mysql"
	"github.com/ttacon/builder"
	"github.com/ttacon/chalk"
	"github.com/ttacon/go-utils/db/sqlutil"
	"github.com/ttacon/pouch/pouch/defs"
	"golang.org/x/tools/imports"
)

var (
	// where to put the generated code
	targetPkg = flag.String("pkg", "", "package to write files to")
	pkgName   = flag.String("pName", "", "pkg name for the generated files")

	// TODO(ttacon): dsn or individual parts?
	// for DB mode
	host     = flag.String("h", "", "db host to connect to")
	user     = flag.String("u", "", "user to connect to db as")
	password = flag.String("p", "", "password to authenticate user with")
	database = flag.String("db", "", "database to read tables from")
	fullDsn  = flag.String("dsn", "", "the uri to use to connect to the database")

	// Prompts
	prompt     = chalk.Green.NewStyle().Style
	warning    = chalk.Yellow.NewStyle().Style
	errorP     = chalk.Red.NewStyle().Style
	dbgenPrmpt = chalk.Magenta.Color("[pouch]")

	// Other things we need...
	gopath = os.Getenv("GOPATH")
)

var (
	errorX  = errorP("✗")
	checkY2 = prompt("✔")
	checkY  = chalk.Green.Color("✔")
	// checkY2 does not give same output as checkY
)

func main() {
	flag.Parse()

	err := loadTemplates()
	if err != nil {
		fmt.Println(dbgenPrmpt, "failed to load templates: "+err.Error())
		return
	}

	if len(*targetPkg) == 0 {
		cwd, err := os.Getwd()
		if err != nil {
			fmt.Println(
				dbgenPrmpt,
				errorP("no target pkg provided + "+
					"failed to retrieve current directory"))
			return
		}
		*targetPkg = cwd
	} else {
		*targetPkg = filepath.Join(gopath, "src", *targetPkg)
	}

	var dirPkg = filepath.Base(*targetPkg)

	if len(*pkgName) >= 0 {
		dirPkg = *pkgName
	}

	var (
		structFileNeeded = false
		entities         []*defs.StructInfo
	)

	if dbInfoProvided(*host, *user, *password, *database) {
		// TODO(ttacon): add option for specific table(s) to be generated for
		dbConn, err := getDBConn(*host, *user, *password, *database)
		if err != nil {
			fmt.Println(dbgenPrmpt, "failed to connect to database: "+err.Error())
			return
		}
		entities, err = generateStructsFrom(dbConn)
		if err != nil {
			fmt.Println(dbgenPrmpt, "failed to generate structs: "+err.Error())
		}
		dbConn.Close()
		structFileNeeded = true
	}

	// file generation
	if structFileNeeded {
		fBytes, err := generateStructCode(entities)
		if err != nil {
			fmt.Println(dbgenPrmpt, "failed to generate struct file, err:", err)
			return
		}

		fBuf := bytes.NewBufferString("package " + dirPkg + "\n\n")
		fBuf.WriteString(`
// THIS FILE IS GENERATED BY pouch.
// EDIT AT YOUR OWN PERIL.
`)
		fBuf.Write(fBytes)
		fBuf.WriteString("\n\n")

		process, err := imports.Process("", fBuf.Bytes(), nil)
		if err != nil {
			fmt.Println(dbgenPrmpt, "failed to process imports for struct file:", err)
			return
		}

		fmt.Print(dbgenPrmpt, " writing file structs.pch.go: ")
		err = ioutil.WriteFile(
			filepath.Join(*targetPkg, "structs.pch.go"),
			process,
			os.FileMode(0744))
		if err != nil {
			fmt.Println(errorX)
			fmt.Println("err: ", err)
			return
		}
		fmt.Println(checkY)
	}

	fmt.Print(dbgenPrmpt, " generating functions (functions.pch.go): ")
	funcCode, err := generateFunctions(entities)
	if err != nil {
		fmt.Println(errorX)
		fmt.Println("err: ", err)
		return
	}

	fBuf := bytes.NewBufferString("package " + dirPkg + "\n\n")
	fBuf.WriteString(`
// THIS FILE IS GENERATED BY pouch.
// EDIT AT YOUR OWN PERIL.
`)
	fBuf.Write(funcCode)
	fBuf.WriteString("\n\n")

	funcCode, err = imports.Process("", fBuf.Bytes(), nil)
	if err != nil {
		fmt.Println(errorX)
		fmt.Println("err: ", err)
		return
	}

	err = ioutil.WriteFile(
		filepath.Join(*targetPkg, "functions.pch.go"),
		funcCode,
		os.FileMode(0644))
	if err != nil {
		fmt.Println(errorX)
		fmt.Println("err: ", err)
		return
	}

	fmt.Println(checkY)
}

func dbInfoProvided(ss ...string) bool {
	for _, s := range ss {
		if len(s) > 0 {
			return true
		}
	}
	return false
}

func generateStructsFrom(db *sql.DB) ([]*defs.StructInfo, error) {
	util := sqlutil.New(db)
	tables, err := util.ShowTables("")
	if err != nil {
		return nil, err
	}

	var toGen = make([]*defs.StructInfo, len(tables))

	for i, table := range tables {
		columns, err := util.DescribeTable(table)
		if err != nil {
			return nil, err
		}

		toGen[i] = structFrom(table, columns)
		toGen[i].Table = table
	}

	return toGen, nil
}

func generateStructCode(toGen []*defs.StructInfo) ([]byte, error) {
	var (
		fileBytes      = builder.NewBuilder(nil)
		templateBuffer = builder.NewBuilder(nil)
	)
	for _, s := range toGen {
		err := structTmplt.Execute(templateBuffer, s)
		if err != nil {
			return nil, err
		}

		fileBytes.Write(templateBuffer.Bytes())
		templateBuffer.Reset()
	}

	return fileBytes.Bytes(), nil
}

func generateFunctions(toGen []*defs.StructInfo) ([]byte, error) {
	var (
		fileBytes = builder.NewBuilder(nil)
	)
	templateToGoThrough := []*template.Template{
		identifiableT,
		insertableT,
		tableablT,
		findableT,
		gettableT,
	}
	for _, s := range toGen {
		for _, templ := range templateToGoThrough {
			err := templ.Execute(fileBytes, s)
			if err != nil {
				return nil, err
			}
		}
	}

	return fileBytes.Bytes(), nil
}

func structFrom(name string, columns []sqlutil.ColumnInfo) *defs.StructInfo {
	var fields = make([]defs.FieldInfo, len(columns))
	var idField *string
	for i, column := range columns {
		fields[i] = defs.FieldInfo{
			Name:      column.Field,
			Column:    column.Field,
			IsPointer: column.Null == "YES",
			Type:      goType(column.Type),
		}
		if column.Key == "PRI" {
			// TODO(ttacon): make this not mysql specific
			fields[i].IsPrimaryKey = true
			if column.Extra == "auto_increment" {
				var f = column.Field
				idField = &f
			}
		}
	}
	s := &defs.StructInfo{
		Name:   name,
		Fields: fields,
	}
	if idField != nil {
		s.IDField = *idField
		s.HasAutoGenIDField = true
	}
	return s
}

func goType(typ string) string {
	// for now let's strip from the first '('
	firstParen := strings.Index(typ, "(")
	if firstParen > 0 {
		typ = typ[:firstParen]
	}
	switch typ {
	case "boolean":
		return "bool"
	case "tinyint":
		return "int8"
	case "tinyint unsigned":
		return "uint8"
	case "smallint":
		return "int16"
	case "smallint unsigned":
		return "uint16"
	case "int":
		return "int"
	case "int unsigned":
		return "uint"
	case "bigint":
		return "int64"
	case "bigint unsigned":
		return "uint64"
		// TODO(ttacon): how should we know about float32s?
	case "double":
		return "float64"
	case "mediumblob":
		return "[]uint8"
	case "datetime":
		return "time.Time"
	default:
		return "string"
	}
}

func getDBConn(host, username, password, database string) (*sql.DB, error) {
	return sql.Open("mysql",
		fmt.Sprintf("%s:%s@%s/%s?parseTime=true", username, password, host, database))
}

// templates
var (
	structTmplt                                  *template.Template
	identifiableT                                *template.Template
	insertableT, tableablT, findableT, gettableT *template.Template
)

func loadTemplates() error {
	var err error
	structTmplt, err = template.New("struct").Parse(structTemplate)
	if err != nil {
		return err
	}

	identifiableT, err = template.New("identifiable").Parse(identifiableTemplate)
	if err != nil {
		return err
	}

	insertableT, err = template.New("insertable").Parse(insertableTemplate)
	if err != nil {
		return err
	}

	tableablT, err = template.New("tableable").Parse(tableableTemplate)
	if err != nil {
		return err
	}

	findableT, err = template.New("findable").Parse(findableTemplate)
	if err != nil {
		return err
	}

	gettableT, err = template.New("gettable").Parse(gettableTemplate)
	if err != nil {
		return err
	}

	return nil
}

////////// templates for function generation //////////
////////// these will go in own file after we test them //////////
var structTemplate = `
type {{.Name}} struct { {{range $i, $v := .Fields}}
    {{$v.Name}} {{if $v.IsPointer}}*{{end}}{{$v.Type}}{{end}}
}
`

// Identifiable
var identifiableTemplate = `
func (i *{{.Name}}) IdentifiableFields() ([]string, []interface{}) {
    var (
        cols []string
        fields []interface{}
    ){{range $i, $v := .Fields}}{{if $v.IsPrimaryKey}}
    // adding primary key column/field pair {{$v.Name}}
    cols = append(cols, "{{$v.Column}}")
    fields = append(fields, i.{{$v.Name}}){{end}}{{end}}
    return cols, fields
}
`

// TODO(ttacon): do we need insertable fields??
// as in, do we need to differentiate "empty" or not?
// it seems like added complexity that isn't entirely necessary
// Insertable
var insertableTemplate = `
func (i *{{.Name}}) FieldsFor(fs []string) []interface{} {
    var fields = make([]interface{}, len(fs))

    for ii, f := range fs {
        switch f { {{range $i, $v := .Fields}}
        case "{{$v.Column}}":
            fields[ii] = &i.{{$v.Name}}{{end}}
        }
    }
    return fields
}

func (i *{{.Name}}) InsertableFields() ([]string, []interface{}) {
    return nil, nil
}

func (i *{{.Name}}) SetIdentifier(d interface{}) error { {{if not .HasAutoGenIDField}}
    return nil
    {{else}}
    id, _ := d.(int64)
    i.{{.IDField}} = int(id)
    return nil
{{end}}}
`

// Tableable
var tableableTemplate = `
func (t *{{.Name}}) Table() string {
    return "{{.Table}}"
}
`

// Findable:FindableCopy
var findableTemplate = `
func (f *{{.Name}}) FindableCopy() pouch.Findable {
    return &{{.Name}}{}
}
`

// Gettable
var gettableTemplate = `
func (g *{{.Name}}) GetFieldsFor(fs []string) []interface{} {
    var fields = make([]interface{}, len(fs))

    for i, f := range fs {
        switch f { {{range $i, $v := .Fields}}
        case "{{$v.Column}}":
            fields[i] = &g.{{$v.Name}}{{end}}
        }
    }
    return fields
}

func (g *{{.Name}}) GetAllFields() ([]string, []interface{}) {
    var cols  = []string{ {{range $i, $v := .Fields}}
        "{{$v.Column}}",{{end}}
    }
    var fields = []interface{}{ {{range $i, $v := .Fields}}
        &g.{{$v.Name}},{{end}}
    }
    return cols, fields
}
`
